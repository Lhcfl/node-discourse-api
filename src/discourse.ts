import EventEmitter from 'eventemitter3';
import { ApiOptions } from '@/types/discourse';
import fetch, { HeadersInit } from 'node-fetch-commonjs';
import { ChatApi } from '@/lib/chat';
import crypto from 'node:crypto';

export type generateUserApiKeyParams = {
  /**
   * the name of the application making the request (will be displayed in the user accountâ€™s Apps tab)
   * @defaultValue `"NodeDiscourseApi"`
   */
  application_name?: string,
  /**
   * url to redirect back to with the generated token
   */
  auth_redirect?: string,
  /**
   * comma-separated list of access scopes allowed for the key, see `allow user api key scopes` for the full list of available scopes
   * 
   * @defaultValue `"read"`
   */
  scopes?: string,
  /**
   * a unique identifier for the client
   * @defaultValue a random 32-bit string
   */
  client_id?: string,
  /**
   * url to push notifications to (required and valid only if `push` or `notifications` are included in the scopes)
   */
  push_url?: string,
  /**
   * the public part of the keypair generated by the client
   */
  public_key?: string,
};

export class DiscourseApiOption {
  
  private _storage: ApiOptions;
  api: DiscourseApi;

  private checkCompatibility() {
    if ((this.api_key || this.api_username) && (this.user_api_key || this.user_api_client_id)) {
      throw 'You cannot specify api_key and user_api_key at the same time';
    }
  }
  
  constructor(api: DiscourseApi, options?:ApiOptions) {
    this.api = api;
    if (options) {
      this._storage = options;
    } else {
      this._storage = {};
    }
    this.checkCompatibility();
  }

  /**
   * Api username
   */
  get api_username(): string | undefined {
    return this._storage.api_username;
  };
  set api_username(str: string) {
    this._storage.api_username = str;
    this.checkCompatibility();
  }
  /**
   * Api key
   */
  get api_key(): string | undefined {
    return this._storage.api_key;
  }
  set api_key(str: string) {
    this._storage.api_key = str;
    this.checkCompatibility();
  }
  /**
   * User Api
   */
  get user_api_key(): string | undefined {
    return this._storage.user_api_key;
  }
  set user_api_key(str: string) {
    this._storage.user_api_key = str;
    this.checkCompatibility();
  }
  /**
   * User Api Client id
   */
  get user_api_client_id(): string | undefined {
    return this._storage.user_api_client_id;
  }
  set user_api_client_id(str: string) {
    this._storage.user_api_client_id = str;
    this.checkCompatibility();
  }
}

export class DiscourseApi extends EventEmitter {

  /**
   * The URL of discourse site
   */
  url: string;
  /**
   * The discourse's options
   */
  options: DiscourseApiOption;
  /**
   * Chat Api
   */
  chat: ChatApi;

  /**
   * Create a api client
   * @param url The URL of your site. Don't add / at the end
   * @param options options
   */
  constructor(url: string, options?: ApiOptions) {
    super();
    this.url = url;
    this.options = new DiscourseApiOption(this, options);
    this.chat = new ChatApi(this);
  }

  /**
   * Get default header
   */
  get _defaultHeaders(): HeadersInit {
    const headers: HeadersInit = {
      'Content-Type': 'application/json',
    };
    if (this.options.api_key) {
      headers['Api-Key'] = this.options.api_key;
    }
    if (this.options.api_username) {
      headers['Api-Username'] = this.options.api_username;
    }
    if (this.options.user_api_key) {
      headers['User-Api-Key'] = this.options.user_api_key;
    }
    if (this.options.user_api_client_id) {
      headers['User-Api-Client-Id'] = this.options.user_api_client_id;
    }
    return headers;
  }

  /**
   * send request easily
   * @param endpoint the endpoint. if the endpoint not starts with '/', we consider it as a url
   * @param method method. defaltly 'GET'
   * @param data request payload
   * @returns Promise
   */
  _request(
    endpoint: string,
    method: 'GET' | 'POST' | 'DELETE' | 'PUT' = 'GET',
    data?: unknown,
    options?: {
      /**
       * When true, we will not automatically add the end of .json when fetching
       */
      doNotSendJSON?: boolean,
      /**
       * custom header
       */
      headers?: HeadersInit,
      /**
       * When true, the options.header will override the default headers. Otherwise, the request will use a header that is a combination of the two
       */
      overrideHeaders?: boolean,
    }
  ) {
    return new Promise((resolve, reject) => {
      if (data) {
        data = JSON.stringify(data);
      }
      if (endpoint.startsWith('/')) {
        const [p1, p2] = endpoint.split('?');
        let urlType = '';
        if (!p1.endsWith('.json') && !options?.doNotSendJSON) {
          urlType = '.json';
        }
        if (p2) {
          endpoint = `${this.url}${p1}${urlType}?${p2}`;
        } else {
          endpoint = `${this.url}${p1}${urlType}`;
        }
      }
      let headers: HeadersInit | undefined;
      if (options?.overrideHeaders) {
        headers = options.headers;
      } else {
        headers = Object.assign({}, this._defaultHeaders, options?.headers);
      }
      fetch(endpoint, {
        method,
        body: data,
        headers,
      }).then((res) => {
        if (res.ok) {
          res.text().then((str) => {
            try {
              resolve(JSON.parse(str));
            } catch (err) {
              resolve(str);
            }
          });
        } else {
          res.text().then((str) => {
            try {
              reject({
                status: res.status,
                statusText: res.statusText,
                body: JSON.parse(str),
              });
            } catch (err) {
              reject({
                status: res.status,
                statusText: res.statusText,
                body: str,
              });
            }
          });
        }
      });

    });
  }

  /**
   * Generate a user api key. 
   * It might be slow if you don't provide a private key because this function will generate it!
   * 
   * For more information, see https://meta.discourse.org/t/user-api-keys-specification/48536
   * 
   * @param params params
   */
  generateUserApiKeySync(params?: generateUserApiKeyParams) {
    const urlParams = new URLSearchParams();
    const res: {
      url: string,
      public_key?: string,
      private_key?: string,
      nonce: string,
    } = {
      url: '',
      nonce: crypto.randomBytes(16).toString('hex'),
    };
    if (!params) {
      params = {};
    }
    urlParams.set('application_name', params.application_name || 'NodeDiscourseApi');
    urlParams.set('scopes', params.scopes || 'read');
    urlParams.set('client_id', params.client_id || 'NodeDiscourseApi');
    if (!params.public_key) {
      const {
        publicKey,
        privateKey,
      } = crypto.generateKeyPairSync('rsa', {
        modulusLength: 2048,
        publicKeyEncoding: {
          type: 'pkcs1',
          format: 'pem',
        },
        privateKeyEncoding: {
          type: 'pkcs8',
          format: 'pem',
        },
      });
      urlParams.set('public_key', publicKey);
      res.private_key = privateKey;
      res.public_key = publicKey;
    } else {
      urlParams.set('public_key', params.public_key);
    }
    
    if (params.auth_redirect) {
      urlParams.set('auth_redirect', params.auth_redirect);
    }
    if (params.push_url) {
      urlParams.set('push_url', params.push_url);
    }
    urlParams.set('nonce', res.nonce);
    res.url = `${this.url}/user-api-key/new?${urlParams.toString()}`;
    return res;
  }

  /**
   * Asynchronously generate a user api key. 
   * 
   * For more information, see https://meta.discourse.org/t/user-api-keys-specification/48536
   * 
   * @param params params
   */
  async generateUserApiKey(params?: generateUserApiKeyParams) {
    return this.generateUserApiKeySync(params);
  }

  /**
   * Revoke a user api key.
   * @param user_api_key The user api key to revoke. If not specified, options.user_api_key is used
   */
  revokeUserApiKey(user_api_key?: string) {
    if (!user_api_key) {
      user_api_key = this.options.user_api_key;
    }
    if (!user_api_key) {
      throw 'No user api key to revoke';
    }
    return this._request('/user-api-key/revoke', 'POST', undefined, {
      headers: {
        'User-Api-Key': user_api_key,
      },
      overrideHeaders: true,
    });
  }
}

